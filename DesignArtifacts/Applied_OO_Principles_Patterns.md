# Identification of object-oriented design principles
## Observer
Observer pattern is used primarily for notification of multiple sources. InventoryModel and OrderModel both implement the Subject interface that defines the management of observers. The Observer interface is implemented by BaristaController, CustomerController, ManagerInventoryController and ManagerMenuController. These classes are therefore responsible for listening for changes. Each of the 4 classes manages changes within their respective I/O source.
## Strategy
The Strategy pattern is thightly connected with the Observer classes in this project. The Observers can be one of several types: BaristaController, CustomerController, ManagerInventoryController and ManagerMenuController. To ensure seamless switching between the updates of these Observers the Strategy pattern enforces polymorphism.
## Factory
BeverageFactory and PastryFactory are concrete impementations of the factory pattern. They extend abstract class MenuItemFactory that produces instances of abstract MenuItem class. Beverage and Pastry classes extend this abstract class and are being produced by their corresponding factories. The concrete classes that implement MenuItem share the same constructor between them that utilizes the superclass' constructor. This makes the factory implementation trivial, because the differences between those classes are represented by attributes that need to be added after the base class is created.
## MVC
The MVC design pattern is implemented through the separation of concerns in project structure. The Model classes hold business logic, represented by classes like Beverage, Inventory and OrderBoard. The View manages data reception and output of the application, and it is represented by fxml resources. These "screens" are loaded in by the Controller classes that manage the data parsing.
# Explanations and examples of principles
## Single Responsibility
In this project the SRP is succesfully applied to guarantee that each class only has one reason to be modified because of its duty. Every class serves specific purpose and doesn't cross the line to hold more attributes and methods than needed for the sake of simplicity. Much of that is due to the MVC structure of the project, which ensures that there are several parts of the project that communicate within strictly defined rules. For example OrderService only manages orders, while OrderModel only manages order observers. 
## High cohesion
The classes of this project clearly show high cohesion which is characterized by condensed classes that hold all of the logic needed without reaching over other classes for unrealted attributes. Major part of high cohesion is SRP, ensuring that the only responsibility is contained within the class or module. For example ProductCatalog only manages the MenuItem collection, essentially being a repository for MenuItem class, but it doesn't take on any responsibility of editing how the menu items should be instantiated.
## Inheritance and Composition
A case of inheritance in this project is MenuItem that is extended by Beverage and Pastry classes. This example showcases how classes inherit the abstract superclass and add their own attributes which intoduces tighter coupling on the superclass, but is ultimately simplier to reuse. The usage of inheritance is justified in this case, because this relationship of abstract part of menu and concrete consumable will not change in the future.
Composition is often more flexible than inheritance. In this project it's represented by Inventory that owns IngredientStock as part of a Map. The has-a relationship is strong, which means that the IngredientStock won't exist outside of Inventory's lifecycle. These classes aren't connected by inheritance because these classes would've violated LSP: one can't be substituted by the other.